## 数据依赖、循环依赖

参考："external2\ipcc\2022-1-ipcc-超算竞赛入门.pdf"
参考：<https://www.bilibili.com/video/BV1794y1U7Rx> 时间点：27:43

### 数据依赖

几种数据依赖的例子，以及如何消除他们实现优化

```c++
for(int i=0;i<100;++i){
   A[i]=A[i]*B[i];   //S1
   B[i]=A[i]*c;      //S2
   A[i]=C[i]*c;      //S3
   C[i]=D[i]*A[i];   //S4
}
```

上面的代码几个地方存在数据依赖，如下：

- 输出相关(写后写)：s1和s3通过A[i]产生了输出相关。
- 反相关(读后写)：s3和s1通过A[i]；s2和s1通过B[i]；s3和s2通过A[i]；s4和s3通过C[i]产生了反相关
- 真数据相关(写后读)：s2和s1通过A[i]；s4和s3通过A[i]产生的真数据相关
  
改写代码，通过重命名去掉输出相关和反相关，修改后的代码如下：

```c++
for(int i=0;i<100;++i){
   A[i]=A[i]*B[i];      //S1
   B1[i]=A[i]*c;        //S2
   A1[i]=C[i]*c;        //S3
   C1[i]=D[i]*A1[i];    //S4
}
```

除去真数据相关的方法会增加计算量，例子如下：

```c++
for(int i=0;i<100;++i){
   A1[i]=A[i]*B[i];           //S1
   B1[i]=A[i]*B[i]*c;         //S2
   ...
}
```

对于之前提到的s2和s1通过A[i]产生真数据相关，上面代码的修改消除它，提高了ILP，但是增加了计算开销：`A[i]*c`变成了`A[i]*B[i]*c`。

### 循环依赖

==todo==

## 循环展开

参考："external2\ipcc\2022-1-ipcc-超算竞赛入门.pdf"
参考：<https://www.bilibili.com/video/BV1794y1U7Rx> 时间点：28:30

优势如下：

- 减少分支跳转(引用中认为，作用没有那么大，因为处理器分支预测准确率超过95%)
- 增加乱序执行的机会，跳转指令不可以和任何指令进行乱序，所以循环展开->减少跳转指令->增加乱序执行的机会
- 增加向量化的机会

展开到什么程度比较合适，如果已经有很好的执行效率(逼近了理论上线)就不需要循环展开。

## 访存优化

因为存储墙的存在，访存需要优化，对于访存密集型应用，访存优化很有必要，在硬件设计上cpu的芯片面积有一半以上是cache

下面介绍几个访存优化的要点

### 减少cache miss

写出处理器更加容易预测的代码，手段如下：

- 显示：编译器指示
- 隐式：处理数据前先排序

### 数据对齐

### 局部性优化

### miscellaneous

- 位运算代替乘除法运算
- 使用内建函数(intrinsic)，手动数据预取，分支概率提示(对编译器做出"提示")
- 内联汇编，精细控制代码的每个细节，用得不好可能性能反而会下降(自定义变量和寄存器的绑定可能会破坏编译器前后的依赖分析)
- 多跑几次(优点：睿频，cache，消除gpu开发中第一次运行的30ms延迟)
